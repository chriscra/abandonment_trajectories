---
title: "R Notebook"
output: html_notebook
editor_options: 
  chunk_output_type: console
---
```{r initialize}
source("scripts/0_start.R")
```

```{r load-data}

# Land use class codes:
#       1. Non-vegetated area (e.g. water, urban, barren land)
#       2. Woody vegetation
#       3. Cropland 
#       4. Herbaceous land (e.g. grassland)

# -------------------------- rasters --------------------------- #
# raw rasters
s <- brick(paste0(p_dat, "Abandonment/shaanxi.tif"))
b <- brick(paste0(p_dat_derived, "belarus.tif")) # merged version

# reprojected rasters:
br <- brick(paste0(p_dat_derived, "belarus_reproj.tif"))

# subset:
bt <- brick(paste0(p_dat_derived, "belarus_subset.tif"))

# age
s_age_r <- brick(paste0(p_dat_derived, "shaanxi_age.tif"))
b_age_r <- brick(paste0(p_dat_derived, "belarus_age.tif"))

# max_length
s_max_length_r <- brick(paste0(p_dat_derived, "shaanxi_max_length.tif"))
b_max_length_r <- brick(paste0(p_dat_derived, "belarus_max_length.tif"))

# update year names 1987 - 2017
names(s) <- paste0("y", 1987:2017)
names(b) <- paste0("y", 1987:2017)
names(br) <- paste0("y", 1987:2017)
names(s_age_r) <- paste0("y", 1987:2017)
names(b_age_r) <- paste0("y", 1987:2017)






# -------------------------- data.tables --------------------------- #

b_age <- fread(input = paste0(p_dat_derived, "belarus_age.csv"))
names(b_age)
s_age <- fread(input = paste0(p_dat_derived, "shaanxi_age.csv"))


b_length <- fread(input = paste0(p_dat_derived, "belarus_length.csv"))
s_length <- fread(input = paste0(p_dat_derived, "shaanxi_length.csv"))

b_max_length <- fread(input = paste0(p_dat_derived, "belarus_max_length.csv"))
s_max_length <- fread(input = paste0(p_dat_derived, "shaanxi_max_length.csv"))

# original data
s_dt <- fread(input = paste0(p_dat_derived, "shaanxi.csv"))
names(s_dt) <- gsub(pattern = "andcover", replacement = "y", names(s_dt))

b_dt <- fread(input = paste0(p_dat_derived, "belarus.csv")) # caution - huge file! 8.4 GB at least.
```

```{r simple-plots}
# crop b to a small area for testing
plot(bt$y2017, main = "Belarus 2017, subset", 
     col = plot_cols$color,
     breaks = c(0, plot_cols$breaks))
legend("bottomleft", cex = 0.7, inset = 0,
       legend = plot_cols$name, 
       fill = plot_cols$color)


```


# Fragmentation analysis
Using the R package `landscapemetrics`, 
```{r load-landscapemetrics}
install.packages("landscapemetrics")
install.packages("landscapetools")
library(landscapemetrics)
library(landscapetools)

# landscape raster
show_landscape(landscape)
res(landscape)

citation("landscapemetrics")
```

`landscapemetrics` works only with rasters with cell resolutions in terms of meters.

"The resolution of a raster cell has to be in meters, as the package converts units internally and returns results in either meters, square meters or hectares. Before using landscapemetrics, be sure to check your raster (see check_raster())."
```{r reproject-check-landscape}
plot(bt$y2017)

# -------------------------------------------------- #
# Reproject, and check_landscape()
btr <- projectRaster(bt, crs = crs("+proj=bonne +lat_1=10 +lon_0=30"), method = "ngb")
writeRaster(btr, filename = paste0(p_dat_derived, "belarus_subset_reproj.tif"))

check_landscape(rp) # checks out
getValues(rp) %>% summary()


plot(btr$y2017, col = plot_cols$color, breaks = c(0, plot_cols$breaks))
animate(btr, col = plot_cols$color, breaks = c(0, plot_cols$breaks), n = 2)


# reproject full brick:
br <- projectRaster(b, crs = crs("+proj=bonne +lat_1=10 +lon_0=30"), method = "ngb")

# save reprojected raster to file:
tic()
writeRaster(br, filename = paste0(p_dat_derived, "belarus_reproj.tif"))
toc()

# testing on just one layer
tic()
br1 <- projectRaster(b$y2017, crs = crs("+proj=bonne +lat_1=10"), method = "ngb")
toc() # 2158 sec

tic()
writeRaster(br1, filename = paste0(p_dat_derived, "belarus_reproj1.tif"))
toc()
plot(br1, col = plot_cols$color, breaks = c(0, plot_cols$breaks))

# 

plot(bt$y1987, col = plot_cols$color, breaks = c(0, plot_cols$breaks))
plot(bt$y2017, col = plot_cols$color, breaks = c(0, plot_cols$breaks))
plot(btr$y1987, col = plot_cols$color, breaks = c(0, plot_cols$breaks))
plot(btr$y2017, col = plot_cols$color, breaks = c(0, plot_cols$breaks))
plot(br$y1987, col = plot_cols$color, breaks = c(0, plot_cols$breaks))
plot(br$y2017, col = plot_cols$color, breaks = c(0, plot_cols$breaks))

# resolution and area
bt_area <- raster::area(bt)
plot(bt_area, main = "bt_area")
median(getValues(bt_area)) * (1000)^2 # 0.00051717 km2, 517.17 m2
res(btr)[1] * res(btr)[2] # = 522 m2
sqrt(median(getValues(r_area))) * (1000) # 22.74 m x 22.74 m, approximately, if sqrt


# ------------------------------------------------------------------ #
# ---------------------- testing grounds --------------------------- #
# ------------------------------------------------------------------ #

r <- bt$y2017

plot(r, col = plot_cols$color, breaks = c(0, plot_cols$breaks))
show_landscape(r)

landscapemetrics::check_landscape(r)

# reproject raster
crs(r)

proj

epsg %>% filter(str_detect(note, regex("Pulkovo", ignore_case = TRUE))) %>% head()


st_crs(r)
st_crs(landscape)

# reproject raster to have units in meters
rp1 <- projectRaster(r, crs = crs("+proj=bonne +lat_1=10"),
                    method = "ngb")
rp2 <- projectRaster(r, crs = crs("+proj=bonne +lat_1=40"),
                     method = "ngb")
rp3 <- projectRaster(r, crs = crs("+proj=bonne +lat_1=60"),
                    method = "ngb")
rp4 <- projectRaster(r, crs = crs("+proj=bonne +lat_1=90"),
                     method = "ngb")
rp5 <- projectRaster(r, crs = crs("+proj=bonne +lat_1=90 +lon_0=30"),
                     method = "ngb")
rp1.2 <- projectRaster(r, crs = crs("+proj=bonne +lat_1=10 +lon_0=30"),
                     method = "ngb")

par(mfrow = c(2, 2))
plot(rp1); plot(rp2); plot(rp3); plot(rp4)
plot(rp1); plot(rp2); plot(rp4); plot(rp5)

rp6 <- projectRaster(r, crs = crs("+proj=tmerc"), method = "ngb")
rp7 <- projectRaster(r, crs = crs("+proj=tmerc +lon_0=30"), method = "ngb")
rp7.1 <- projectRaster(r, crs = crs("+proj=tmerc +lon_0=20"), method = "ngb")
rp7.2 <- projectRaster(r, crs = crs("+proj=tmerc +lon_0=40"), method = "ngb")
rp7.3 <- projectRaster(r, crs = crs("+proj=tmerc +lon_0=35"), method = "ngb")
rp7.4 <- projectRaster(r, crs = crs("+proj=tmerc +lon_0=25"), method = "ngb")

rp8 <- projectRaster(r, crs = crs("+proj=tmerc +lat_0=0 +lon_0=9 +k_0=1 +x_0=3500000 +y_0=0 +ellps=bessel +units=m"), method = "ngb")
rp9 <- projectRaster(r, crs = crs("+proj=utm +zone=36"), method = "ngb")
rp10 <- projectRaster(r, crs = crs("+proj=utm +zone=35"), method = "ngb")
rp11 <- projectRaster(r, crs = crs("+proj=utm +zone=37"), method = "ngb")

plot(rp6); plot(rp7); plot(rp8); plot(rp5, main = "rp5")
plot(rp6); plot(rp7); plot(rp9); plot(rp5, main = "rp5")
plot(rp9); plot(rp10); plot(rp11); plot(rp5, main = "rp5")

plot(rp7); plot(rp7.1); plot(rp7.2); plot(rp5, main = "rp5")
plot(rp7); plot(rp7.3); plot(rp7.4); plot(rp5, main = "rp5")


rp7


par(mfrow = c(2, 2))
plot(rp4); plot(rp5)
plot(r); plot(r, col = plot_cols$color, breaks = c(0, plot_cols$breaks))

res(rp1)
res(rp2)
res(rp3)
res(rp4)
res(rp5)
res(rp5)[1] * res(rp5)[2]
res(rp6)
res(rp7)
res(rp8)
res(rp9)
res(rp10)
res(rp11)


plot(rp5, col = plot_cols$color, breaks = c(0, plot_cols$breaks))
plot(rp9, col = plot_cols$color, breaks = c(0, plot_cols$breaks))



```

```{r binarize}
plot(btr$y2017, main = "Belarus 2017, subset", col = plot_cols$color, breaks = c(0, plot_cols$breaks))
legend("bottomleft", cex = 0.7, inset = 0, legend = plot_cols$name, fill = plot_cols$color)

# Original Land-use class codes:
#       1. Non-vegetated area (e.g. water, urban, barren land)
#       2. Woody vegetation
#       3. Cropland 
#       4. Herbaceous land (e.g. grassland)


# This chunk updates these land cover classes to:
#       0. Cropland
#       1. Noncrop - grassland (formerly 4) or woody vegetation (formerly 2)

binary <- btr
binary[binary == 1] <- NA # non-veg
binary[binary == 3] <- 0  # Cropland
binary[binary == 4] <- 1  # Grassland
binary[binary == 2] <- 1  # Woody vegetation


# 0-1-2, increasing scale of vegetation structure
binary2 <- btr
binary2[binary2 == 1] <- NA # non-veg
binary2[binary2 == 3] <- 0  # Cropland
binary2[binary2 == 4] <- 1  # Grassland
binary2[binary2 == 2] <- 2  # Woody vegetation

animate(binary)
animate(binary2)



# to remove the 0s:
plot(br$y1987, #col = plot_cols$color, breaks = c(0, plot_cols$breaks),
     ext = ext)
ext <- drawExtent(show = TRUE, col = "red")

br_test <- crop(br$y1987, ext)
plot(br_test)
br_test[br_test == 0] <- NA
plot(br_test)
# It works!
```

## Background
### Levels of metrics
Three levels of landscape metrics:
1. patch - an individual patch in the landscape (clump)
2. **class** - one categorical class, such as 4 - woody vegetation
3. *landscape* - the landscape as a whole, the entire raster. These metrics summarize the entire landscape into a single value

### Classes of landscape metrics
1. *Area and edge metrics*
2. Shape metrics - largely based on the perimeter and the area.
3. Core metrics, about the area of the patch that is not on an edge.
4. *Aggregation* metrics, describing if patches (of the same class) are rather clumped (aggregated) or tend to be isolated. Following, these metrics describe mainly the spatial configuration of the landscape.
5. Diversity metrics, describing the diversity of different classes in the landscape.
6. Complexity metrics, which describe landscape complexity in new ways outside of FRAGSTATS, including: Marginal entropy [H(x)], Conditional entropy [H(y|x)], Joint entropy [H(x, y)], and Mutual information [I(y,x)]. (Not likely to use these.)

## Metrics of interest

Area and edge: what is the average patch area for each class (ag, grassland, woody vegetation, and how does this change over time? Does abandonment make the average patch area for a particular class grow over time, or not?)

Aggregation: is the landscape as a whole more densely aggregated, or clumped together like with like? In otherwords, how distributed or mixed are the different land use classes throughout the landscape?

```{r explore-fragstats}
bt
btr
br

# look at the data again
plot(btr$y2017, col = plot_cols$color, breaks = c(0, plot_cols$breaks))
animate(btr, col = plot_cols$color, breaks = c(0, plot_cols$breaks), n = 2)

show_landscape(btr$y2017)

show_landscape(landscape)
show_patches(landscape)
show_patches(landscape, class = "all", labels = FALSE)

check_landscape(btr) # 
check_landscape(br) # full dataset
# 5 classes, all checks out ok. 

list_lsm()
list_lsm(level = "landscape", simplify = TRUE) # just the 

# Explore metrics
list_lsm(level = "landscape", type = "aggregation metric", simplify = FALSE) %>% print(n = 14)
list_lsm(type = "aggregation metric", simplify = FALSE) %>% print(n = 30)
list_lsm(level = "landscape", simplify = FALSE) %>% print(n = 65)
list_lsm(type = "area and edge metric", simplify = FALSE) %>% print(n = 24)


metrics_list <- c(
  # aggregation metrics
  "lsm_l_ai", # aggregation index, landscape level
  "lsm_c_ai", # aggregation index, class level
  "lsm_l_cohesion", # patch cohesion index, landscape
  "lsm_c_cohesion", # patch cohesion index, class
  "lsm_c_enn_mn", # euclidean nearest neighbor distance, mean, class

  "lsm_l_contag", # connectance
  "lsm_l_np", # number of patches
  "lsm_l_pd", # patch density
  
  # shape metric
  "lsm_l_contig_mn", # contiguity index
  
  # area and edge metrics
  "lsm_l_area_mn", # patch area, mean, landscape overall
  "lsm_c_area_mn", # patch area, mean, per class
  "lsm_c_ca", # total (class) area
  "lsm_l_lpi", # largest patch index, landscape
  "lsm_c_lpi" # largest patch index, class
  )

# test area
tic()
lsm_c_ca(btr$y2017)
toc() # 0.029

tic()
lsm_c_ca(br$y2017)
toc() # 37.178
37.178 / 0.029
90 * 1282 / 60 / 60

ncell(br)/ncell(btr)

# so, it's 
(61120 + 2037336 + 1114915 + 1712799) / (24.5 + 40 + 50.6) # times as large
42799 * 1.5 / 60

# calculate metrics for subset
check_landscape(btr[[1:5]])
show_landscape(btr$y2017)

tic()
btr_metrics <- btr %>%
  calculate_lsm(
    #type = "aggregation metric",
    #level = "landscape",
    what = metrics_list,
    classes_max = 3,
    verbose = TRUE,
    progress = TRUE
    ) %>%
  dplyr::left_join(x = .,
                   y = lsm_abbreviations_names, 
                   by = c("metric", "level"))
toc() # 93.7 seconds

btr_metrics %>% print(n=65)
  

show_correlation(ls_metrics, method = "pearson")
1987:2017
as.character(1:31)
# fct_recode(as_factor(layer), 
#                             1987 = "1", 1988 = "2", 1989 = "3", 
#                             1990 = "4", 1991 = "5", 1992 = "6", 
#                             1993 = "7", 1994 = "8", 1995 = "9", 
#                             1996 = "10", 1997 = "11", 1998 = "12", 
#                             1999 = "13", 2000 = "14", 2001 = "15", 
#                             2002 = "16", 2003 = "17", 2004 = "18", 
#                             2005 = "19", 2006 = "20", 2007 = "21", 
#                             2008 = "22", 2009 ="23", 2010 = "24", 
#                             2011 = "25", 2012 = "26", 2013 = "27", 
#                             2014 = "28", 2015 = "29", 2016 = "30", 
#                             2017 = "31")

btr_metrics <- btr_metrics %>% 
  mutate(land_cover = fct_recode(as_factor(class), 
                            woody_veg = "2", cropland = "3", grassland = "4"),
         year = layer + 1986) %>%
  select(class) %>%
  unique()

```

```{r stats-to-run}
# Question: to what extent does abandonment result in older, larger, and more connected grasslands and forests? 

# select landscape metrics to run:
# what matters to species? size of patches, shape/area edge perimeter, connectivity
list_lsm() %>% arrange(level, type, name) %>% select(function_name, name, type, level) %>% select(name) %>% unlist(use.names = FALSE) %>% grep(pattern = "total edge", ., value = TRUE)# %>% print(n = 132)

list_lsm() %>% arrange(level, type, name) %>% select(function_name, name, type, level) %>% filter(name == "total edge")

# ---------------------------- #
# Wang et al. 2014, Methods in Ecology and Evolution, recommends 9 metrics, largely because they are relatively uncorrelated with habitat abundance, and have high correlation with spatial aggregation:

# too complicated.
# 1. PAFRAC (Shape) - "Perimeter Area Fractal Dimension"
lsm_c_pafrac() # perimeter-area fractal dimension

# too hard to conceptualize... and dependent on definitions of edge effects.
# 2. CAI_CV (Core Area) - "Coefficient of Variation of Core Area Index"
# 3. CAI_MN (Core Area) - "Mean Core Area Index"
# 4. CAI_SD (Core Area) - "Standard Deviation of Core Area Index"
lsm_c_cai_mn() # edge_depth by default is one cell.

# 5. CORE_CV (Core Area) - "Coefficient of Variation of Core Area"
lsm_c_core_cv() # edge_depth by default is one cell. 

# 6. PROX_CV (Proximity/Isolation) - "Coefficient of Variation of Proximity Index"


# only useful if I assign values to different classes (saying forest has less contrast with grassland than with ag land, for example)
# 7. ECON_AM (Contrast) - "Area Weighted Mean Edge Contrast Index"
# 8. TECI (Contrast) - "Total Edge Contrast Index"

# yes
# 9. CLUMPY (Contagion/Interspersion) - "Clumpy Index"

# ---------------------------- #
# RS has used:
# Aggregation Index
# Cohesion Index

# ---------------------------- #
# I think the most important metrics probably are:
# at least one aggregation, connectivity metric
# *1. Aggregation
# *2. Clumpy
# 3. Cohesion (maybe not)

# Are the patches getting larger?
# *4. Number of patches
# *5. Mean, SD, and CV of Patch area (x3)
# *5.1. Class area, total.

# Is the amount of edge increasing, decreasing, or staying the same?
# *6. Total edge amount.
# *6.1. Perimeter-area ratio (x3)
# 6.2 Perimeter area fractal dimension

# probably not:
# 7. Core area index
# 7. Contiguity Index (x3) - may be resource intensive. 

# just the basics 
metrics_list <- c(
  "lsm_c_ai", # aggregation index, class level (RS has used this one)
  "lsm_c_clumpy", # clumpiness index, class (maybe)

  "lsm_c_np", # number of patches, class
  "lsm_c_area_cv", # patch area, cv, per class
  "lsm_c_area_mn", # patch area, mean, per class
  "lsm_c_area_sd", # patch area, sd, per class
  "lsm_c_ca", # total (class) area
  
  "lsm_c_te", # total edge
  "lsm_c_para_cv", # perimeter-area ratio, cv
  "lsm_c_para_mn", # perimeter-area ratio, mean
  "lsm_c_para_sd" # perimeter-area ratio, sd
)

# longer list of metrics
# ---------------------------- #
metrics_list_bonus_c <- c(
  # by class 
  # aggregation
  "lsm_c_mesh", # effective mesh size, class
  
  "lsm_c_enn_cv", # euclidean nearest neighbor distance, cv, class
  "lsm_c_enn_mn", # euclidean nearest neighbor distance, mean, class
  "lsm_c_enn_sd", # euclidean nearest neighbor distance, sd, class
  
  "lsm_c_cohesion", # patch cohesion index, class (RS has used this one)
  "lsm_c_pd", # patch density (maybe)
  
  "lsm_c_lpi", # largest patch index, class
  
  # core area metrics
  "lsm_c_cai_cv", # core area index, cv, class
  "lsm_c_cai_mn", # core area index, mn, class
  "lsm_c_cai_sd", # core area index, sd, class
  
  # shape metric
  "lsm_c_contig_cv", # contiguity index, class, cv
  "lsm_c_contig_mn", # contiguity index, class, mean
  "lsm_c_contig_sd", # contiguity index, class, sd
  
  "lsm_c_pafrac", # perimeter-area fractal dimension
  
  "lsm_c_shape_cv", # shape index, cv
  "lsm_c_shape_mn", # shape index, mean
  "lsm_c_shape_sd" # shape index, sd
)

metrics_list_l <- c(
  # landscape
  # aggregation metrics
  "lsm_l_ai", # aggregation index, landscape level
  "lsm_l_contag", # connectance
  "lsm_l_mesh", # effective mesh size, landscape

  "lsm_l_contig_cv", # contiguity index, landscape, cv
  "lsm_l_contig_mn", # contiguity index, landscape, mean
  "lsm_l_contig_sd", # contiguity index, landscape, sd

  "lsm_l_cohesion", # patch cohesion index, landscape
  "lsm_l_np", # number of patches
  "lsm_l_pd", # patch density
  # shape metric
  # area and edge metrics
  "lsm_l_area_mn", # patch area, mean, landscape overall
  "lsm_l_lpi" # largest patch index, landscape
)

# list the metrics
print(list_lsm(what = metrics_list_c))

```


```{r run-lsm-full}
names(br)
names(b)

# first, prep raster, to remove 0s
br
br[br == 0] <- NA

summary(getValues(br$y1987))

# run, for a subset of the metrics
tic()
br_metrics1 <- br %>%
  calculate_lsm(
    #type = "aggregation metric",
    #level = "landscape",
    what = metrics_list[c(1, 2, 6, 9)],
    classes_max = 4,
    verbose = TRUE,
    progress = TRUE
    ) %>%
  dplyr::left_join(x = .,
                   y = lsm_abbreviations_names, 
                   by = c("metric", "level"))
toc() # 3954 sec

# Save file
write_rds(br_metrics1, paste0(p_output, "frag/br_metrics1.rds"))

# reload
br_metrics1 <- read_rds(paste0(p_output, "frag/br_metrics1.rds"))


list_lsm(what = metrics_list)


# full list:
tic()
check_br <- check_landscape(br)
print(check_br)
toc()

tic()
br_metrics2 <- br %>%
  calculate_lsm(
    what = metrics_list[c(3, 4, 5, 7, 8)],
    classes_max = 5,
    verbose = TRUE, progress = TRUE
    ) %>%
  dplyr::left_join(x = .,
                   y = lsm_abbreviations_names, 
                   by = c("metric", "level"))
toc() #  sec

# Save file
tic()
write_rds(br_metrics2, paste0(p_output, "frag/br_metrics2.rds"))
toc()
```


```{r aggregation-stats}
aggregation <- lsm_l_ai(binary)
aggregation2 <- lsm_l_ai(btr)
ggplot() + 
  geom_point(data = aggregation, mapping = aes(x = layer, y = value, col = "blue"), size = 3) + 
  geom_point(data = aggregation2, mapping = aes(x = layer, y = value, col = "red")) + 
  theme_classic()


# calculate aggregation statistic 
check_landscape(br)
agg_br <- lsm_l_ai(br)
ggplot(data = agg_br) + 
  geom_point(mapping = aes(x = layer, y = value#, color = "blue"
                           )) + 
  geom_smooth(method = "lm", mapping = aes(x = layer, y = value)) + 
  #geom_point(data = aggregation2, mapping = aes(x = layer, y = value, col = "red")) + 
  labs(x = "Year", y = "Aggregation Index"#, title = "Aggregation"
       ) + 
  theme_classic()


# calc patch cohesion index
agg_cohesion <- lsm_l_cohesion(bt)
animate(bt)

```

The cluster cannot handle running all of the metrics for Belarus raster, across all of the years. So far, the Shaanxi raster is running, with 150 GB of memory, but just for the first five metrics. It may not finish, since it's just through the first 2 layers. That does not look promising. So, what I need to do is either reduce the number of metrics per run, or reduce the number of years per run, or both. 

Update (10/19/20):
Based on the exploration in the chunk "stats-to-run" above, I narrowed down the landscape metrics to run to just 11:
1. "lsm_c_ai", # aggregation index, class level (RS has used this one)
2. "lsm_c_clumpy", # clumpiness index, by class
3. "lsm_c_np", # number of patches, class
4-6. "lsm_c_area_cv", # patch area, cv, mean, and sd, per class
7. "lsm_c_ca", # total (class) area

8. "lsm_c_te", # total edge
9-11. "lsm_c_para_cv", # perimeter-area ratio, cv, mean, and sd

I was able to calculate all 11 metrics for shaanxi, but only the first 7 for belarus. The edge calculating metrics were highly memory intensive, and couldn't be calculated, even with 350 gb allocated per node to adroit. The error was: 
"Error: cannot allocate vector of size 184.9 Gb
Execution halted
Warning message:
system call failed: Cannot allocate memory"

I ended up running each metric as an individual run on adroit, making use of the array capability in SLURM. This is sort of like a manually set up parallelization. To do this, I set an array range in the SLURM script, and set the rscript up to grab that variable from the environment (), and use it to specify which metric to run from the list (`metrics_list`). I was able to do each of the first 7 using the less than 100 gb, less than 4 hours (for both shaanxi and belarus). I had to up the memory available for 8-11 to 350 gb (though according to slurm, it only utilized 136 gb, so could probably just go to 200 gb or so for next time), and it took about 2 hours (add a bit more just to be safe). 

Even with this, though, Belarus wouldn't run 8-11 (edge). I tried to break this up by layer, again manually parallelizing to run each layer of the raster brick as an individual run. But, it still ran into issues allocating a vector of size 190 gb or so. I'll try again with 350 gb limit, but not likely to work. I'll likely need to either write up code to do this with google earth engine, or break up the raster to run in smaller chunks.


```{r prep-cluster-runs}
# -------------------------------------------------------- #
# Christopher Crawford, Princeton University, October 12th, 2020

# Script to calculate various landscape metrics, 
# using the R package landscapemetrics
# -------------------------------------------------------- #

# load libraries
cluster_packages <- c("data.table", "tictoc", "raster",
                      "landscapemetrics", "landscapetools",
                      "tidyverse", "rgdal")
install_pkg <- lapply(cluster_packages, library, character.only = TRUE)

# set paths:
p_dat_derived <- "/scratch/network/clc6/abandonment_trajectories/data_derived/"
p_output <- "/scratch/network/clc6/abandonment_trajectories/output/"

# set site:
site <- "shaanxi"
run <- 1
print(paste0("Calculating landscapemetrics for ", site, ", run #", run))


tic.clearlog()
tic("Full script")
# load the data
# -------------------------------------------------------- #

# (re)load reprojected rasters
tic("load the cleaned reprojected rasters")
reprojected_r <- brick(paste0(p_dat_derived, site, "_reproj_0rm.tif"))
toc(log = TRUE)

names(reprojected_r) <- paste0("y", 1987:2017) # rename

# # check_landscapes
# tic("check landscape")
# check_reprojected_r <- check_landscape(reprojected_r)
# print(check_reprojected_r)
# toc(log = TRUE)

# Metrics to run
metrics_list <- c(
  "lsm_c_ai", # aggregation index, class level (RS has used this one)
  "lsm_c_clumpy", # clumpiness index, class (maybe)

  "lsm_c_np", # number of patches, class
  "lsm_c_area_cv", # patch area, cv, per class
  "lsm_c_area_mn", # patch area, mean, per class
  "lsm_c_area_sd", # patch area, sd, per class
  "lsm_c_ca", # total (class) area
  
  
  # careful - these require much more memory
  "lsm_c_te", # total edge
  "lsm_c_para_cv", # perimeter-area ratio, cv
  "lsm_c_para_mn", # perimeter-area ratio, mean
  "lsm_c_para_sd" # perimeter-area ratio, sd
)



print(list_lsm(what = metrics_list[run]))

tic(msg = paste0("calculate: ", metrics_list[run]))
frag_metrics_temp <- reprojected_r %>%
  calculate_lsm(
    what = metrics_list[run],
    classes_max = 4, # with 0 removed
    verbose = TRUE, progress = TRUE
  ) %>%
  dplyr::left_join(x = .,
                   y = lsm_abbreviations_names,
                   by = c("metric", "level"))
toc(log = TRUE)

# rename file
assign(paste0("frag_metrics_", site, run), frag_metrics_temp)

# Save file
tic(msg = paste0("save: ", metrics_list[run]))
save(list = c(paste0("frag_metrics_", site, run)),
     file = paste0(p_output, "frag_metrics_", site, run, ".rds")
     )
toc(log = TRUE)


toc(log = TRUE) # final toc

print(tic.log())



# as a for loop:
# 
# frag_metrics_l <- vector(mode = "list", length = length(metrics_list))
# names(frag_metrics_l) <- metrics_list
# 
# tic("calculate lsm")
# for (i in seq_along(metrics_list)) {
#   tic(msg = paste0("calculate: ", metrics_list[i]))
#   frag_metrics_l[i] <- reprojected_r %>%
#     calculate_lsm(
#       what = metrics_list[i],
#       classes_max = 4, # with 0 removed
#       verbose = TRUE, progress = TRUE
#     ) %>%
#     dplyr::left_join(x = .,
#                      y = lsm_abbreviations_names, 
#                      by = c("metric", "level"))
#   
#   assign(paste0("area", outfile_label), area)
#   save(frag_metrics_l, 
#        file = paste0(p_output, "frag_", metrics_list[i], ".rds")
#        )
#   
# 
# }
# toc(log = TRUE)



```

```{r highmem-lsm}
metrics_list[8]
lsm_c_te()
metrics_list[9]
lsm_c_para_cv()

metrics_list[8:11]
lsm_c_te()

b$y1987 %>% ncell()

```


```{r clean-frag-results}
# -------------------------------------------------------- #
# site <- "shaanxi"
site <- "belarus"


cc_clean_frag_results(site = "shaanxi")
load(file = paste0(p_output, "frag/frag_", "shaanxi", ".rds"),
         verbose = TRUE)

cc_clean_frag_results(site = "belarus")
load(file = paste0(p_output, "frag/frag_", "belarus", ".rds"),
         verbose = TRUE)

frag_shaanxi %>% select(metric, name, function_name) %>% unique
frag_belarus %>% select(metric, name, function_name) %>% unique



```

## Plot Fragmentation Metrics
```{r load-frag-metrics}
load(file = paste0(p_output, "frag/frag_", "shaanxi", ".rds"), verbose = TRUE)
load(file = paste0(p_output, "frag/frag_", "belarus", ".rds"), verbose = TRUE)

frag_shaanxi %>% select(metric, name, function_name) %>% unique
frag_belarus %>% select(metric, name, function_name) %>% unique


# combined sites into a single data.frame
frag_dat <- bind_rows(frag_shaanxi, frag_belarus)
save(frag_dat, file = paste0(p_output, "frag/frag_dat.rds"))
load(file = paste0(p_output, "frag/frag_dat.rds"), verbose = TRUE)

# 11. metrics calculated (though not for each site)
frag_dat %>% select(metric, name, function_name) %>% unique

frag_dat %>% filter(site == "shaanxi") %>% select(metric, name, function_name) %>% unique
frag_dat %>% filter(site == "belarus") %>% select(metric, name, function_name) %>% unique


# ------------------------------------------ #
# ------------ Fragmentation --------------- #
# ------------------------------------------ #
cc_save_frag_plots(input = frag_dat, outfile_label = NULL)
```


```{r 1-aggregation}
frag_dat %>% select(metric, name, function_name) %>% unique

# ------------------- 1. aggregation -------------------- #
gg_frag_base <- ggplot(data = filter(frag_dat, 
                                   metric == "ai",
                                   land_cover != "non_veg"
                                   )) +
  theme_classic() +
  geom_point(mapping = aes(x = year, y = value, color = land_cover)) + 
  geom_smooth(method = "lm", mapping = aes(x = year, y = value,
                                           fill = land_cover, 
                                           color = land_cover)) +
  labs(x = "Year", color = "Land Cover") + 
  guides(fill = FALSE) +
  facet_grid(cols = vars(site), scales = "free_y")

gg_frag_ai <- gg_frag_base %+% filter(frag_dat, metric == "ai", land_cover != "non_veg") + 
  labs(title = "Aggregation Index, by land cover",
       y = "Index Value")


frag_dat$land_cover %>% unique


land_cover_cols <- c("non_veg" = plot_cols$color[1], 
                     "woody_veg" = plot_cols$color[2], 
                     "cropland" = plot_cols$color[3], 
                     "grassland" = plot_cols$color[4])
gg_frag_base %+% filter(frag_dat, metric == "ai", land_cover != "non_veg") + 
  labs(title = "Aggregation Index, by land cover",
       y = "Index Value") +
  scale_colour_manual(
    values = land_cover_cols,
    aesthetics = c("colour", "fill"), labels = plot_cols$name[2:4]
    )


gg_frag_ai

plot_cols
```


```{r 2-clumpiness}
frag_dat %>% select(metric, name, function_name) %>% unique

# ------------------- 2. clumpiness -------------------- #
gg_frag_clumpy <- gg_frag_base %+% filter(frag_dat, metric == "clumpy", land_cover != "non_veg") + 
  labs(title = "Clumpiness Index, by land cover",
       y = "Index Value")


gg_frag_clumpy <- ggplot(data = filter(frag_dat, 
                                   metric == "clumpy",
                                   land_cover != "non_veg"
                                   )) +
  theme_classic() +
  geom_point(mapping = aes(x = year, y = value, color = land_cover)) + 
  geom_smooth(method = "lm", mapping = aes(x = year, y = value,
                                           fill = land_cover, 
                                           color = land_cover)) +
  labs(title = "Clumpiness Index, by land cover",
       x = "Year", y = "Index Value",
       color = "Land Cover") + 
  guides(fill = FALSE) +
  facet_grid(cols = vars(site))
gg_frag_clumpy
```


```{r aggregation-combo}

# ------------------- aggregation combo -------------------- #

gg_frag_aggregation_combo <- ggplot(data = filter(frag_dat, 
                     metric %in% c("ai", "clumpy"),
                     land_cover != "non_veg")) +
  theme_classic() +
  geom_point(mapping = aes(x = year, y = value, color = land_cover)) + 
  geom_smooth(method = "lm", mapping = aes(x = year, y = value,
                                           fill = land_cover, 
                                           color = land_cover)) +
  labs(title = "Aggregation Index, by land cover",
       x = "Year", y = "Index Value",
       color = "Land Cover") + 
  guides(fill = FALSE) +
  facet_grid(cols = vars(site), rows = vars(metric), scales = "free_y")
gg_frag_aggregation_combo
```


```{r 3-num-patches}
frag_dat %>% select(metric, name, function_name) %>% unique

# ------------------- 3. Number of patches -------------------- #

gg_frag_np <- ggplot(data = filter(frag_dat, 
                                   metric == "np",
                                   land_cover != "non_veg"
                                   )) +
  theme_classic() +
  geom_point(mapping = aes(x = year, y = value/(10^3), color = land_cover)) + 
  geom_smooth(method = "lm", mapping = aes(x = year, y = value/(10^3),
                                           fill = land_cover, 
                                           color = land_cover)) +
  labs(title = "Number of patches, by land cover",
       x = "Year", y = expression("Number of patches  (10"^{3}*")") , 
       color = "Land Cover") + 
  guides(fill = FALSE) +
  facet_grid(cols = vars(site))

gg_frag_np
```


```{r 4-patch-area-cv}
# ------------------- 4. Patch area, coefficient of variation -------------------- #
frag_dat %>%
  filter(metric == "area_cv") %>%
  group_by(land_cover) %>%
  summarise(mean = mean(value))


# https://r-spatialecology.github.io/landscapemetrics/reference/lsm_c_area_cv.html
# units: hectares
metrics_list
gg_frag_patch_area_cv <- ggplot(data = filter(frag_dat, 
                                   metric == "area_cv",
                                   land_cover != "non_veg"
                                   )) +
  theme_classic() +
  geom_point(mapping = aes(x = year, y = value, color = land_cover)) + 
  geom_smooth(method = "lm", mapping = aes(x = year, y = value,
                                           fill = land_cover, 
                                           color = land_cover)) +
  labs(title = "Patch area coefficient of variation",
       x = "Year", y = "Patch Area CV (ha)", 
       color = "Land Cover") + 
  guides(fill = FALSE) +
  facet_grid(cols = vars(site), scales = "free_y")

gg_frag_patch_area_cv

```

```{r 5-patch-area-mn}
# ------------------- 5. Patch area, mean -------------------- #
frag_dat %>%
  filter(metric == "area_mn") %>%
  group_by(land_cover) %>%
  summarise(mean = mean(value))


# https://r-spatialecology.github.io/landscapemetrics/reference/lsm_c_area_mn.html
# units: hectares
metrics_list
gg_frag_patch_area_mn <- ggplot(data = filter(frag_dat, 
                                   metric == "area_mn",
                                   land_cover != "non_veg"
                                   )) +
  theme_classic() +
  geom_point(mapping = aes(x = year, y = value, color = land_cover)) + 
  geom_smooth(method = "lm", mapping = aes(x = year, y = value,
                                           fill = land_cover, 
                                           color = land_cover)) +
  labs(title = "Mean patch area, by land cover",
       x = "Year", y = "Patch Area mean (ha)", 
       color = "Land Cover") + 
  guides(fill = FALSE) +
  facet_grid(cols = vars(site), scales = "free_y")

gg_frag_patch_area_mn

```

```{r 6-patch-area-sd}
# ------------------- 6. Patch area, standard deviation -------------------- #
frag_dat %>%
  filter(metric == "area_sd") %>%
  group_by(land_cover) %>%
  summarise(mean = mean(value))


# https://r-spatialecology.github.io/landscapemetrics/reference/lsm_c_area_sd.html
# units: hectares
metrics_list
gg_frag_patch_area_sd <- ggplot(data = filter(frag_dat, 
                                   metric == "area_sd",
                                   land_cover != "non_veg"
                                   )) +
  theme_classic() +
  geom_point(mapping = aes(x = year, y = value, color = land_cover)) + 
  geom_smooth(method = "lm", mapping = aes(x = year, y = value,
                                           fill = land_cover, 
                                           color = land_cover)) +
  labs(title = "Patch area standard deviation, by land cover",
       x = "Year", y = "Patch Area sd (ha)", 
       color = "Land Cover") + 
  guides(fill = FALSE) +
  facet_grid(cols = vars(site), scales = "free_y")

gg_frag_patch_area_sd

```

```{r patch-area-combo}
# units in hectares

# ------------------- patch area combo -------------------- #

gg_frag_patch_area_combo <- 
  ggplot(data = filter(frag_dat, 
                       metric %in% c("area_cv", "area_mn", "area_sd"),
                       land_cover != "non_veg")) +
  theme_classic() +
  geom_point(mapping = aes(x = year, y = value, color = land_cover)) + 
  geom_smooth(method = "lm", mapping = aes(x = year, y = value,
                                           fill = land_cover, 
                                           color = land_cover)) +
  labs(title = "Patch Area, by land cover",
       x = "Year", y = "Index Value",
       color = "Land Cover") + 
  guides(fill = FALSE) +
  facet_grid(cols = vars(site), rows = vars(metric), scales = "free_y",
             labeller = labeller(
               metric = c(
                 area_cv = "Coeff. Var.", 
                 area_mn = "Mean",  
                 area_sd = "Std. Dev.")
               ))

gg_frag_patch_area_combo


gg_frag_patch_area_cv
gg_frag_patch_area_mn
gg_frag_patch_area_sd
```

```{r 7-class-area}
# ------------------- 7. Total class area  -------------------- #
frag_dat %>%
  filter(metric == "ca") %>%
  group_by(land_cover) %>%
  summarise(mean = mean(value))


# https://r-spatialecology.github.io/landscapemetrics/reference/lsm_c_ca.html
# units: hectares
frag_dat %>% select(metric, name, function_name) %>% unique

gg_frag_ca <- ggplot(data = filter(frag_dat, 
                                   metric == "ca",
                                   land_cover != "non_veg"
                                   )) +
  theme_classic() +
  geom_point(mapping = aes(x = year, y = value/(10^6), color = land_cover)) + 
  geom_line(mapping = aes(x = year, y = value/(10^6), color = land_cover)) + 
  
  # geom_smooth(method = "lm", mapping = aes(x = year, y = value/(10^6),
  #                                          fill = land_cover, 
  #                                          color = land_cover)) +
  labs(title = "Total area in each land cover type",
       x = "Year", y = expression("Class Area (10"^{6}*" ha)"), 
       color = "Land Cover") + 
  guides(fill = FALSE) +
  facet_grid(cols = vars(site), scales = "free_y")

gg_frag_ca



```


```{r 8-total-edge}
# ------------------- 8. Total edge (meters) -------------------- #
frag_dat %>%
  filter(metric == "te") %>%
  group_by(land_cover) %>%
  summarise(mean = mean(value))

frag_dat %>% select(metric, name, function_name) %>% unique

# https://r-spatialecology.github.io/landscapemetrics/reference/lsm_c_te.html
# units: meters

gg_frag_te <- ggplot(data = filter(frag_dat, 
                                   metric == "te",
                                   land_cover != "non_veg"
                                   )) +
  theme_classic() +
  geom_point(mapping = aes(x = year, y = value/(10^6), color = land_cover)) + 
  geom_smooth(method = "lm", mapping = aes(x = year, y = value/(10^6),
                                           fill = land_cover,
                                           color = land_cover)) +
  labs(title = "Total edge in each land cover type",
       x = "Year", y = expression("Total edge (10"^{3}*" km)"), 
       color = "Land Cover") + 
  guides(fill = FALSE) +
  facet_grid(cols = vars(site), scales = "free_y")

gg_frag_te


```

```{r 9-11-perimeter-area-ratio}
frag_dat %>% select(metric, name, function_name) %>% unique

# ------------------- 9. Perimeter-area ratio (coefficient of variation) -------------------- #

# https://r-spatialecology.github.io/landscapemetrics/reference/lsm_c_area_mn.html
# units: ratio, unitless

# ------------------- perimeter-area ratio combo -------------------- #

gg_frag_para_combo <- 
  ggplot(data = filter(frag_dat, 
                       metric %in% c("para_cv", "para_mn", "para_sd"),
                       land_cover != "non_veg")) +
  theme_classic() +
  geom_point(mapping = aes(x = year, y = value, color = land_cover)) + 
  geom_smooth(method = "lm", mapping = aes(x = year, y = value,
                                           fill = land_cover, 
                                           color = land_cover)) +
  labs(title = "Perimeter-Area Ratio, by land cover",
       x = "Year", y = "Perimeter-Area Ratio",
       color = "Land Cover") + 
  guides(fill = FALSE) +
  facet_grid(cols = vars(site), rows = vars(metric), scales = "free_y",
             labeller = labeller(
               metric = c(
                 para_cv = "Coeff. Var.", 
                 para_mn = "Mean",  
                 para_sd = "Std. Dev.")
               ))

gg_frag_para_combo



gg_frag_para_cv <- ggplot(data = filter(frag_dat, 
                                   metric == "para_cv",
                                   land_cover != "non_veg"
                                   )) +
  theme_classic() +
  geom_point(mapping = aes(x = year, y = value, color = land_cover)) + 
  geom_smooth(method = "lm", mapping = aes(x = year, y = value,
                                           fill = land_cover,
                                           color = land_cover)) +
  labs(title = "Perimeter-Area Ratio, by land cover",
       x = "Year", y = "Perimeter-Area Ratio (cv)", 
       color = "Land Cover") + 
  guides(fill = FALSE) +
  facet_grid(cols = vars(site), scales = "free_y")

gg_frag_para_cv

gg_frag_para_mn <- ggplot(data = filter(frag_dat, 
                                   metric == "para_mn",
                                   land_cover != "non_veg"
                                   )) +
  theme_classic() +
  geom_point(mapping = aes(x = year, y = value, color = land_cover)) + 
  geom_smooth(method = "lm", mapping = aes(x = year, y = value,
                                           fill = land_cover,
                                           color = land_cover)) +
  labs(title = "Perimeter-Area Ratio, by land cover",
       x = "Year", y = "Perimeter-Area Ratio (mean)", 
       color = "Land Cover") + 
  guides(fill = FALSE) +
  facet_grid(cols = vars(site), scales = "free_y")

gg_frag_para_mn

gg_frag_para_sd <- ggplot(data = filter(frag_dat, 
                                   metric == "para_sd",
                                   land_cover != "non_veg"
                                   )) +
  theme_classic() +
  geom_point(mapping = aes(x = year, y = value, color = land_cover)) + 
  geom_smooth(method = "lm", mapping = aes(x = year, y = value,
                                           fill = land_cover,
                                           color = land_cover)) +
  labs(title = "Perimeter-Area Ratio, by land cover",
       x = "Year", y = "Perimeter-Area Ratio (sd)", 
       color = "Land Cover") + 
  guides(fill = FALSE) +
  facet_grid(cols = vars(site), scales = "free_y")

gg_frag_para_sd



```





```{r old-plots}
# old
# 2. aggregation, landscape
gg_aggregation_index_br <- ggplot() +
  theme_classic() +
  geom_point(data = filter(br_metrics1, function_name == "lsm_l_ai"),
             mapping = aes(x = year, y = value, fill = level)) + 
  geom_smooth(method = "lm", 
              data = filter(br_metrics1, function_name == "lsm_l_ai"),
              mapping = aes(x = year, y = value, fill = level)) + 
  
  # add by class
  geom_point(data = filter(br_metrics1, function_name == "lsm_c_ai"),
             mapping = aes(x = year, y = value, 
                           group = land_cover, color = land_cover)
             ) + 
  geom_smooth(method = "lm", 
              data = filter(br_metrics1, function_name == "lsm_c_ai"),
              mapping = aes(x = year, y = value,
                            group = land_cover, color = land_cover)) +
  labs(title = "Aggregation Index",
       fill = "Entire \nLandscape",
       color = "Land Cover")
gg_aggregation_index_br

# 3. connectance, landscape
br_metrics1 %>% select(name, function_name) %>% unique()

gg_connectance_br <- ggplot(data = filter(br_metrics1, function_name == "lsm_l_contag")) +
  theme_classic() +
  geom_point(mapping = aes(x = year, y = value)) + 
  geom_smooth(method = "lm", 
              mapping = aes(x = year, y = value)) +
  labs(title = "Connectance")


# 4. mean contiguity index, landscape
gg_contiguity_br <- ggplot(data = filter(br_metrics1, function_name == "lsm_l_contig_mn")) +
  theme_classic() +
  geom_point(mapping = aes(x = year, y = value)) + 
  geom_smooth(method = "lm", 
              mapping = aes(x = year, y = value)) +
  labs(title = "Contiguity Index, Mean")

plot_grid(gg_aggregation_index_br,
          plot_grid(gg_connectance_br, gg_contiguity_br, nrow = 1),
          nrow = 2)


# save plot:
plot_grid(gg_aggregation_index_br,
          plot_grid(gg_connectance_br, gg_contiguity_br, nrow = 1),
          nrow = 2)


png(filename = paste0(p_output, "plots/br_lsm_metrics1.3.png"), 
    width = 7, height = 5, units = "in", res = 400)
print(
  plot_grid(
    plot_grid(gg_connectance_br, gg_contiguity_br, nrow = 2, align = "v"),
    gg_aggregation_index_br,
    ncol = 2,
    rel_widths = c(3, 5)
    )
  )

dev.off()


```

```{r aggregation-crop-vs-combo-veg}
# It looks like woody vegetation becomes less aggregated over time, and grassland become more aggregated over time. This is possibly because the additional forest being gained may be more dispersed, in the fields that area abandoned. The grasslands may become more aggregated over time, as more and more ag land is abandoned and goes into grassland. 
gg_frag_ai
gg_frag_clumpy

# Q. What do aggregation patterns look like if we consider woody vegetation and grassland together as a single class?



```

