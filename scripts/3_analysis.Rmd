---
title: "R Notebook"
output: html_notebook
editor_options: 
  chunk_output_type: console
---
```{r initialize}
source("scripts/0_start.R")
```

```{r load-data}

# Land use class codes:
#       1. Non-vegetated area (e.g. water, urban, barren land)
#       2. Woody vegetation
#       3. Cropland 
#       4. Herbaceous land (e.g. grassland)

# -------------------------- rasters --------------------------- #
# raw rasters
s <- brick(paste0(p_dat, "Abandonment/shaanxi.tif"))
b <- brick(paste0(p_dat_derived, "belarus.tif")) # merged version

# reprojected rasters:
br <- brick(paste0(p_dat_derived, "belarus_reproj.tif"))

# subset:
bt <- brick(paste0(p_dat_derived, "belarus_subset.tif"))

# age
s_age_r <- brick(paste0(p_dat_derived, "shaanxi_age.tif"))
b_age_r <- brick(paste0(p_dat_derived, "belarus_age.tif"))

# max_length
s_max_length_r <- brick(paste0(p_dat_derived, "shaanxi_max_length.tif"))
b_max_length_r <- brick(paste0(p_dat_derived, "belarus_max_length.tif"))

# update year names 1987 - 2017
names(s) <- paste0("y", 1987:2017)
names(b) <- paste0("y", 1987:2017)
names(br) <- paste0("y", 1987:2017)
names(s_age_r) <- paste0("y", 1987:2017)
names(b_age_r) <- paste0("y", 1987:2017)






# -------------------------- data.tables --------------------------- #

b_age <- fread(input = paste0(p_dat_derived, "belarus_age.csv"))
names(b_age)
s_age <- fread(input = paste0(p_dat_derived, "shaanxi_age.csv"))


b_length <- fread(input = paste0(p_dat_derived, "belarus_length.csv"))
s_length <- fread(input = paste0(p_dat_derived, "shaanxi_length.csv"))

b_max_length <- fread(input = paste0(p_dat_derived, "belarus_max_length.csv"))
s_max_length <- fread(input = paste0(p_dat_derived, "shaanxi_max_length.csv"))

# original data
s_dt <- fread(input = paste0(p_dat_derived, "shaanxi.csv"))
names(s_dt) <- gsub(pattern = "andcover", replacement = "y", names(s_dt))

b_dt <- fread(input = paste0(p_dat_derived, "belarus.csv")) # caution - huge file! 8.4 GB at least.
```

```{r simple-plots}
# crop b to a small area for testing
plot(bt$y2017, main = "Belarus 2017, subset", 
     col = plot_cols$color,
     breaks = c(0, plot_cols$breaks))
legend("bottomleft", cex = 0.7, inset = 0,
       legend = plot_cols$name, 
       fill = plot_cols$color)


```

```{r}

```


# Fragmentation analysis
Using the R package `landscapemetrics`, 
```{r load-landscapemetrics}
install.packages("landscapemetrics")
install.packages("landscapetools")
library(landscapemetrics)
library(landscapetools)

# landscape raster
show_landscape(landscape)
res(landscape)

citation("landscapemetrics")
```

`landscapemetrics` works only with rasters with cell resolutions in terms of meters.

"The resolution of a raster cell has to be in meters, as the package converts units internally and returns results in either meters, square meters or hectares. Before using landscapemetrics, be sure to check your raster (see check_raster())."
```{r reproject-check-landscape}
plot(bt$y2017)

# -------------------------------------------------- #
# Reproject, and check_landscape()
btr <- projectRaster(bt, crs = crs("+proj=bonne +lat_1=10 +lon_0=30"), method = "ngb")
writeRaster(btr, filename = paste0(p_dat_derived, "belarus_subset_reproj.tif"))

check_landscape(rp) # checks out
getValues(rp) %>% summary()


plot(btr$y2017, col = plot_cols$color, breaks = c(0, plot_cols$breaks))
animate(btr, col = plot_cols$color, breaks = c(0, plot_cols$breaks), n = 2)


# reproject full brick:
br <- projectRaster(b, crs = crs("+proj=bonne +lat_1=10 +lon_0=30"), method = "ngb")

# save reprojected raster to file:
tic()
writeRaster(br, filename = paste0(p_dat_derived, "belarus_reproj.tif"))
toc()

# testing on just one layer
tic()
br1 <- projectRaster(b$y2017, crs = crs("+proj=bonne +lat_1=10"), method = "ngb")
toc() # 2158 sec

tic()
writeRaster(br1, filename = paste0(p_dat_derived, "belarus_reproj1.tif"))
toc()
plot(br1, col = plot_cols$color, breaks = c(0, plot_cols$breaks))

# 

plot(bt$y1987, col = plot_cols$color, breaks = c(0, plot_cols$breaks))
plot(bt$y2017, col = plot_cols$color, breaks = c(0, plot_cols$breaks))
plot(btr$y1987, col = plot_cols$color, breaks = c(0, plot_cols$breaks))
plot(btr$y2017, col = plot_cols$color, breaks = c(0, plot_cols$breaks))
plot(br$y1987, col = plot_cols$color, breaks = c(0, plot_cols$breaks))
plot(br$y2017, col = plot_cols$color, breaks = c(0, plot_cols$breaks))

# resolution and area
bt_area <- raster::area(bt)
plot(bt_area, main = "bt_area")
median(getValues(bt_area)) * (1000)^2 # 0.00051717 km2, 517.17 m2
res(btr)[1] * res(btr)[2] # = 522 m2
sqrt(median(getValues(r_area))) * (1000) # 22.74 m x 22.74 m, approximately, if sqrt


# ------------------------------------------------------------------ #
# ---------------------- testing grounds --------------------------- #
# ------------------------------------------------------------------ #

r <- bt$y2017

plot(r, col = plot_cols$color, breaks = c(0, plot_cols$breaks))
show_landscape(r)

landscapemetrics::check_landscape(r)

# reproject raster
crs(r)

proj

epsg %>% filter(str_detect(note, regex("Pulkovo", ignore_case = TRUE))) %>% head()


st_crs(r)
st_crs(landscape)

# reproject raster to have units in meters
rp1 <- projectRaster(r, crs = crs("+proj=bonne +lat_1=10"),
                    method = "ngb")
rp2 <- projectRaster(r, crs = crs("+proj=bonne +lat_1=40"),
                     method = "ngb")
rp3 <- projectRaster(r, crs = crs("+proj=bonne +lat_1=60"),
                    method = "ngb")
rp4 <- projectRaster(r, crs = crs("+proj=bonne +lat_1=90"),
                     method = "ngb")
rp5 <- projectRaster(r, crs = crs("+proj=bonne +lat_1=90 +lon_0=30"),
                     method = "ngb")
rp1.2 <- projectRaster(r, crs = crs("+proj=bonne +lat_1=10 +lon_0=30"),
                     method = "ngb")

par(mfrow = c(2, 2))
plot(rp1); plot(rp2); plot(rp3); plot(rp4)
plot(rp1); plot(rp2); plot(rp4); plot(rp5)

rp6 <- projectRaster(r, crs = crs("+proj=tmerc"), method = "ngb")
rp7 <- projectRaster(r, crs = crs("+proj=tmerc +lon_0=30"), method = "ngb")
rp7.1 <- projectRaster(r, crs = crs("+proj=tmerc +lon_0=20"), method = "ngb")
rp7.2 <- projectRaster(r, crs = crs("+proj=tmerc +lon_0=40"), method = "ngb")
rp7.3 <- projectRaster(r, crs = crs("+proj=tmerc +lon_0=35"), method = "ngb")
rp7.4 <- projectRaster(r, crs = crs("+proj=tmerc +lon_0=25"), method = "ngb")

rp8 <- projectRaster(r, crs = crs("+proj=tmerc +lat_0=0 +lon_0=9 +k_0=1 +x_0=3500000 +y_0=0 +ellps=bessel +units=m"), method = "ngb")
rp9 <- projectRaster(r, crs = crs("+proj=utm +zone=36"), method = "ngb")
rp10 <- projectRaster(r, crs = crs("+proj=utm +zone=35"), method = "ngb")
rp11 <- projectRaster(r, crs = crs("+proj=utm +zone=37"), method = "ngb")

plot(rp6); plot(rp7); plot(rp8); plot(rp5, main = "rp5")
plot(rp6); plot(rp7); plot(rp9); plot(rp5, main = "rp5")
plot(rp9); plot(rp10); plot(rp11); plot(rp5, main = "rp5")

plot(rp7); plot(rp7.1); plot(rp7.2); plot(rp5, main = "rp5")
plot(rp7); plot(rp7.3); plot(rp7.4); plot(rp5, main = "rp5")


rp7


par(mfrow = c(2, 2))
plot(rp4); plot(rp5)
plot(r); plot(r, col = plot_cols$color, breaks = c(0, plot_cols$breaks))

res(rp1)
res(rp2)
res(rp3)
res(rp4)
res(rp5)
res(rp5)[1] * res(rp5)[2]
res(rp6)
res(rp7)
res(rp8)
res(rp9)
res(rp10)
res(rp11)


plot(rp5, col = plot_cols$color, breaks = c(0, plot_cols$breaks))
plot(rp9, col = plot_cols$color, breaks = c(0, plot_cols$breaks))



```

```{r binarize}
plot(btr$y2017, main = "Belarus 2017, subset", col = plot_cols$color, breaks = c(0, plot_cols$breaks))
legend("bottomleft", cex = 0.7, inset = 0, legend = plot_cols$name, fill = plot_cols$color)

# Original Land-use class codes:
#       1. Non-vegetated area (e.g. water, urban, barren land)
#       2. Woody vegetation
#       3. Cropland 
#       4. Herbaceous land (e.g. grassland)


# This chunk updates these land cover classes to:
#       0. Cropland
#       1. Noncrop - grassland (formerly 4) or woody vegetation (formerly 2)

binary <- btr
binary[binary == 1] <- NA # non-veg
binary[binary == 3] <- 0  # Cropland
binary[binary == 4] <- 1  # Grassland
binary[binary == 2] <- 1  # Woody vegetation


# 0-1-2, increasing scale of vegetation structure
binary2 <- btr
binary2[binary2 == 1] <- NA # non-veg
binary2[binary2 == 3] <- 0  # Cropland
binary2[binary2 == 4] <- 1  # Grassland
binary2[binary2 == 2] <- 2  # Woody vegetation

animate(binary)
animate(binary2)

```

## Background
### Levels of metrics
Three levels of landscape metrics:
1. patch - an individual patch in the landscape (clump)
2. **class** - one categorical class, such as 4 - woody vegetation
3. *landscape* - the landscape as a whole, the entire raster. These metrics summarize the entire landscape into a single value

### Classes of landscape metrics
1. *Area and edge metrics*
2. Shape metrics - largely based on the perimeter and the area.
3. Core metrics, about the area of the patch that is not on an edge.
4. *Aggregation* metrics, describing if patches (of the same class) are rather clumped (aggregated) or tend to be isolated. Following, these metrics describe mainly the spatial configuration of the landscape.
5. Diversity metrics, describing the diversity of different classes in the landscape.
6. Complexity metrics, which describe landscape complexity in new ways outside of FRAGSTATS, including: Marginal entropy [H(x)], Conditional entropy [H(y|x)], Joint entropy [H(x, y)], and Mutual information [I(y,x)]. (Not likely to use these.)

### Metrics of interest

Area and edge: what is the average patch area for each class (ag, grassland, woody vegetation, and how does this change over time? Does abandonment make the average patch area for a particular class grow over time, or not?)

Aggregation: is the landscape as a whole more densely aggregated, or clumped together like with like? In otherwords, how distributed or mixed are the different land use classes throughout the landscape?

```{r explore-fragstats}
bt
btr
br

# look at the data again
plot(btr$y2017, col = plot_cols$color, breaks = c(0, plot_cols$breaks))
animate(btr, col = plot_cols$color, breaks = c(0, plot_cols$breaks), n = 2)

show_landscape(btr$y2017)

show_landscape(landscape)
show_patches(landscape)
show_patches(landscape, class = "all", labels = FALSE)

check_landscape(btr) # 
check_landscape(br) # full dataset
# 5 classes, all checks out ok. 

list_lsm()
list_lsm(level = "landscape", simplify = TRUE) # just the 

# Explore metrics
list_lsm(level = "landscape", type = "aggregation metric", simplify = FALSE) %>% print(n = 14)
list_lsm(type = "aggregation metric", simplify = FALSE) %>% print(n = 30)
list_lsm(level = "landscape", simplify = FALSE) %>% print(n = 65)
list_lsm(type = "area and edge metric", simplify = FALSE) %>% print(n = 24)


metrics_list <- c(
  # aggregation metrics
  "lsm_l_ai", # aggregation index, landscape level
  "lsm_c_ai", # aggregation index, class level
  "lsm_l_cohesion", # patch cohesion index, landscape
  "lsm_c_cohesion", # patch cohesion index, class
  "lsm_c_enn_mn", # euclidean nearest neighbor distance, mean, class

  "lsm_l_contag", # connectance
  "lsm_l_np", # number of patches
  "lsm_l_pd", # patch density
  
  # shape metric
  "lsm_l_contig_mn", # contiguity index
  
  # area and edge metrics
  "lsm_l_area_mn", # patch area, mean, landscape overall
  "lsm_c_area_mn", # patch area, mean, per class
  "lsm_c_ca", # total (class) area
  "lsm_l_lpi", # largest patch index, landscape
  "lsm_c_lpi" # largest patch index, class
  )

# test area
tic()
lsm_c_ca(btr$y2017)
toc() # 0.029

tic()
lsm_c_ca(br$y2017)
toc() # 37.178
37.178 / 0.029
90 * 1282 / 60 / 60

ncell(br)/ncell(btr)

# so, it's 
(61120 + 2037336 + 1114915 + 1712799) / (24.5 + 40 + 50.6) # times as large
42799 * 1.5 / 60

# calculate metrics for subset
check_landscape(btr[[1:5]])
show_landscape(btr$y2017)

tic()
btr_metrics <- btr %>%
  calculate_lsm(
    #type = "aggregation metric",
    #level = "landscape",
    what = metrics_list,
    classes_max = 3,
    verbose = TRUE,
    progress = TRUE
    ) %>%
  dplyr::left_join(x = .,
                   y = lsm_abbreviations_names, 
                   by = c("metric", "level"))
toc() # 93.7 seconds

btr_metrics %>% print(n=65)
  

show_correlation(ls_metrics, method = "pearson")
1987:2017
as.character(1:31)
# fct_recode(as_factor(layer), 
#                             1987 = "1", 1988 = "2", 1989 = "3", 
#                             1990 = "4", 1991 = "5", 1992 = "6", 
#                             1993 = "7", 1994 = "8", 1995 = "9", 
#                             1996 = "10", 1997 = "11", 1998 = "12", 
#                             1999 = "13", 2000 = "14", 2001 = "15", 
#                             2002 = "16", 2003 = "17", 2004 = "18", 
#                             2005 = "19", 2006 = "20", 2007 = "21", 
#                             2008 = "22", 2009 ="23", 2010 = "24", 
#                             2011 = "25", 2012 = "26", 2013 = "27", 
#                             2014 = "28", 2015 = "29", 2016 = "30", 
#                             2017 = "31")

btr_metrics <- btr_metrics %>% 
  mutate(land_cover = fct_recode(as_factor(class), 
                            woody_veg = "2", cropland = "3", grassland = "4"),
         year = layer + 1986) %>%
  select(class) %>%
  unique()

```


```{r run-lsm-full}
names(br)
names(b)

# first, prep raster, to remove 0s
br
br[br == 0] <- NA

summary(getValues(br$y1987))

# run, for a subset of the metrics
tic()
br_metrics1 <- br %>%
  calculate_lsm(
    #type = "aggregation metric",
    #level = "landscape",
    what = metrics_list[c(1, 2, 6, 9)],
    classes_max = 4,
    verbose = TRUE,
    progress = TRUE
    ) %>%
  dplyr::left_join(x = .,
                   y = lsm_abbreviations_names, 
                   by = c("metric", "level"))
toc() # 3954 sec

# Save file
write_rds(br_metrics1, paste0(p_output, "frag/br_metrics1.rds"))

# reload
br_metrics1 <- read_rds(paste0(p_output, "frag/br_metrics1.rds"))


list_lsm(what = metrics_list)


# full list:
tic()
check_br <- check_landscape(br)
print(check_br)
toc()

tic()
br_metrics2 <- br %>%
  calculate_lsm(
    what = metrics_list[c(3, 4, 5, 7, 8)],
    classes_max = 5,
    verbose = TRUE, progress = TRUE
    ) %>%
  dplyr::left_join(x = .,
                   y = lsm_abbreviations_names, 
                   by = c("metric", "level"))
toc() #  sec

# Save file
tic()
write_rds(br_metrics2, paste0(p_output, "frag/br_metrics2.rds"))
toc()
```

```{r plot-metrics}
# massage dataframe
  # Original Land-use class codes:
  #       1. Non-vegetated area (e.g. water, urban, barren land)
  #       2. Woody vegetation
  #       3. Cropland 
  #       4. Herbaceous land (e.g. grassland)

br_metrics1 <- br_metrics1 %>% 
  mutate(land_cover = fct_recode(as_factor(class), 
                                 non_veg = "1", woody_veg = "2", 
                                 cropland = "3", grassland = "4"),
         year = layer + 1986) %>%
  # drop 0 land cover class
  filter(land_cover %in% c("non_veg", "woody_veg", "cropland", "grassland", NA))


br_metrics1 %>%
  select(land_cover, level) %>%
  unique()

br_metrics1 %>% 
  filter(level == "landscape")

br_metrics1 %>% select(name, function_name) %>% unique()

# four metrics:
# 1. aggregation, class
# 2. aggregation, landscape
# 3. connectance, landscape
# 4. mean contiguity index, landscape


# seven values per year (31 years * 7 = 217 values) [having removed 0 class]
# 4 classes, aggregation, then each of the single landscape metrics


# 1. aggregation, class
ggplot() +
  theme_classic() +
  geom_point(data = filter(br_metrics1, function_name == "lsm_c_ai"),
             mapping = aes(x = year, y = value, 
                           group = land_cover, color = land_cover)
             ) + 
  labs(title = "Aggregation Index, by land cover",
       color = "Land Cover")


# 2. aggregation, landscape
gg_aggregation_index_br <- ggplot() +
  theme_classic() +
  geom_point(data = filter(br_metrics1, function_name == "lsm_l_ai"),
             mapping = aes(x = year, y = value, fill = level)) + 
  geom_smooth(method = "lm", 
              data = filter(br_metrics1, function_name == "lsm_l_ai"),
              mapping = aes(x = year, y = value, fill = level)) + 
  
  # add by class
  geom_point(data = filter(br_metrics1, function_name == "lsm_c_ai"),
             mapping = aes(x = year, y = value, 
                           group = land_cover, color = land_cover)
             ) + 
  geom_smooth(method = "lm", 
              data = filter(br_metrics1, function_name == "lsm_c_ai"),
              mapping = aes(x = year, y = value,
                            group = land_cover, color = land_cover)) +
  labs(title = "Aggregation Index",
       fill = "Entire \nLandscape",
       color = "Land Cover")
gg_aggregation_index_br

# 3. connectance, landscape
br_metrics1 %>% select(name, function_name) %>% unique()

gg_connectance_br <- ggplot(data = filter(br_metrics1, function_name == "lsm_l_contag")) +
  theme_classic() +
  geom_point(mapping = aes(x = year, y = value)) + 
  geom_smooth(method = "lm", 
              mapping = aes(x = year, y = value)) +
  labs(title = "Connectance")


# 4. mean contiguity index, landscape
gg_contiguity_br <- ggplot(data = filter(br_metrics1, function_name == "lsm_l_contig_mn")) +
  theme_classic() +
  geom_point(mapping = aes(x = year, y = value)) + 
  geom_smooth(method = "lm", 
              mapping = aes(x = year, y = value)) +
  labs(title = "Contiguity Index, Mean")

plot_grid(gg_aggregation_index_br,
          plot_grid(gg_connectance_br, gg_contiguity_br, nrow = 1),
          nrow = 2)


# save plot:
plot_grid(gg_aggregation_index_br,
          plot_grid(gg_connectance_br, gg_contiguity_br, nrow = 1),
          nrow = 2)


png(filename = paste0(p_output, "plots/br_lsm_metrics1.3.png"), 
    width = 7, height = 5, units = "in", res = 400)
print(
  plot_grid(
    plot_grid(gg_connectance_br, gg_contiguity_br, nrow = 2, align = "v"),
    gg_aggregation_index_br,
    ncol = 2,
    rel_widths = c(3, 5)
    )
  )

dev.off()


```

```{r aggregation-stats}
aggregation <- lsm_l_ai(binary)
aggregation2 <- lsm_l_ai(btr)
ggplot() + 
  geom_point(data = aggregation, mapping = aes(x = layer, y = value, col = "blue"), size = 3) + 
  geom_point(data = aggregation2, mapping = aes(x = layer, y = value, col = "red")) + 
  theme_classic()


# calculate aggregation statistic 
check_landscape(br)
agg_br <- lsm_l_ai(br)
ggplot(data = agg_br) + 
  geom_point(mapping = aes(x = layer, y = value#, color = "blue"
                           )) + 
  geom_smooth(method = "lm", mapping = aes(x = layer, y = value)) + 
  #geom_point(data = aggregation2, mapping = aes(x = layer, y = value, col = "red")) + 
  labs(x = "Year", y = "Aggregation Index"#, title = "Aggregation"
       ) + 
  theme_classic()


# calc patch cohesion index
agg_cohesion <- lsm_l_cohesion(bt)
animate(bt)

```


# Spatial Regression
