---
title: "Trajectories of Abandonment and Biodiversity, start document"
output: html_notebook
editor_options: 
  chunk_output_type: console
---
Repository for work to investigate the trajectories of abandoned agricultural land, and implications for biodiversity

```{r initialize}
source("scripts/0_start.R")
```

```{r load-rasters}

# Land use class codes:
#       1. Non-vegetated area (e.g. water, urban, barren land)
#       2. Woody vegetation
#       3. Cropland 
#       4. Herbaceous land (e.g. grassland)

bs <- brick(paste0(p_dat, "Abandonment/belarus_small.tif"))
plot(bs)
plot(bs$smolensk1987)
dt_bs <- as.data.table.raster(bs)


# update column names
names(dt_bs) <- gsub("smolensk", "y", names(dt_bs))
dt_bs

object_size(dt_bs)
nlayers(bs) # 31 years in the time series
ncol(dt_bs) # 31 years, plus x and y = 33.


# full landsat scene, but just for individual years
b87_r <- raster("/Users/christophercrawford/Google Drive/_Projects/data/Abandonment/belarus_1987.tif")
b88_r <- raster("/Users/christophercrawford/Google Drive/_Projects/data/Abandonment/belarus_1988.tif")

plot(b87_r)
plot(b88_r)
extent(b87_r)
extent(b88_r)
ncell(b87_r)
ncell(b88_r)

# as data.tables
tic()
dt_b87 <- as.data.table.raster(b87_r)
toc()

dt_b88 <- as.data.table.raster(b88_r)
object_size(dt_b87)
object_size(dt_b87[, .(x, y)])
object_size(dt_b87[, .(belarus_1987)]) # 378 MB approximately for each year.
object_size(dt_b87) + object_size(dt_b87[, .(belarus_1987)])*30 # this is an approximation of how large the full data.table of the full scene, as a data.table, would be. 
# 13.2 GB. This is huge. I'll have to come up with some better way to do this... 
# perhaps start by figuring this out in R, then transfer it to python, and then google earth. 

object_size(dt_b88)


dt_b87_88 <- merge(dt_b87, dt_b88, by = c("x","y"), sort = FALSE)
object_size(dt_b87_88)
object_size(dt_b87_88[, .(belarus_1987, belarus_1988)])


dt_b87_88_sub <- dt_b87_88[belarus_1987 > 0]

dt_b87_88_sub[, sum := (belarus_1987 + belarus_1988)]


names(dt_b87_88)[3] <- "y1988"

object_size(belarus_1988)

plot(belarus_1988, main = "Belarus 1988")

hist(belarus_1988, main = "Belarus 1988 distribution of values")
cellStats(belarus_1988, stat = "min") # 1
cellStats(belarus_1988, stat = "max") # 4


belarus_1988

dt_b87_88[, .N]
dt_b87_88[y1988 == 2, ][, .(value = 2, count = .N)]
dt_b87_88[y1988 == 2, ][, sum(y1988)]
dt_b87_88[, sum(y1988)]

hist(dt_b87_88[, 3])

dt_b87_88_counts <- dt_b87_88[, .(count = .N), by = y1988]

barplot(data = dt_b87_88_counts, count ~ y1988)
```

```{r colors}
# define color palette for plotting:
# 1. Non-veg
# 2. Woody veg
# 3. Crop
# 4. Grassland
plot_cols <- c("gray80", # gray, 1. Non-veg
               terrain.colors(9)[1], # dark green, 2. Woody veg
               terrain.colors(9)[5], # gold, 3. Crop
               terrain.colors(9)[3] # light green, 4. Grassland
               )
plot_cols_new <- c("gray80", # gray, 1. Non-veg
               terrain.colors(9)[5], # gold, 2 (formerly 3) Crop
               terrain.colors(9)[3], # light green, 3 (formerly 4) Grassland
               terrain.colors(9)[1]  # dark green, 4 (formerly 2) Woody veg
               )

plot_breaks <- c(0, 1, 2, 3, 4)


show_col(plot_cols)
show_col(plot_cols[c(1, 3, 2)])
```

```{r simple-plots}
show_col(plot_cols) # (topleft = 1, topright = 2, bottomleft = 3, bottomright = 4)
# gray,         1. Non-veg
# dark green,   2. Woody veg
# gold,         3. Crop
# light green,  4. Grassland

plot(b87_r, main = "Belarus 1987", breaks = plot_breaks, col = plot_cols)
plot(bs$smolensk1987, add = T, legend = F, col = "blue")
plot(bt$smolensk1987, add = T, legend = F, col = "red")
bs

plot(bs$smolensk1987, main = "Subset: Belarus 1987", 
     breaks = plot_breaks, col = plot_cols)

plot(bt$smolensk1987, main = "Subset Subset: Belarus 1987", 
     breaks = plot_breaks, col = plot_cols)
bin

# --------------
# animate
# --------------
# https://www.rdocumentation.org/packages/raster/versions/3.1-5/topics/animate

animate(bt, pause = 0.5, zlim = c(1, 4), maxpixels=5000, n=1,
        breaks = plot_breaks, col = plot_cols)

```

```{r subset-for-testing}
plot(bs$smolensk1987)
mapView(bs$smolensk1987)
ext_bt <- drawExtent(show = TRUE, col = "red")

bt <- crop(bs, ext_bt)
plot(bt$smolensk1987)

object_size(bt)


# --------------
# update values
# --------------

test <- bt$smolensk1987
test[test == 2] <- 7 # take, woody veg (2), set to 7
test[test == 3] <- 2 # take cropland (3), set to 2
test[test == 4] <- 3 # take grassland (4), set to 3
test[test == 7] <- 4 # take 7 (woody veg), set to 4

plot(test)
plot(bt$smolensk1987, breaks = plot_breaks, col = plot_cols)
plot(test, breaks = plot_breaks, col = plot_cols_new)

# --------------
# update to simple, 1 = cropland, 2 = noncropland
# --------------
btb <- bt
plot(btb[[1]], breaks = plot_breaks, col = plot_cols) # 1 = nonveg, 2 = woody, 3 = crop, 4 = grassland
btb[btb == 1] <- NA
btb[btb == 3] <- 1 # crop
btb[btb %in% c(2, 4)] <- 2 # noncrop

# to make it binary, just subtract 1.


plot(bt[[1]], breaks = plot_breaks, col = plot_cols) # 1 = nonveg, 2 = woody, 3 = crop, 4 = grassland

plot(btb[[1]], breaks = c(-1, 0, 1, 2), col = plot_cols[c(1, 3, 2)])
# 1 = brown, agriculture
# 2 = green, non-agriculture

animate(btb, pause = 0.5, zlim = c(1, 4), maxpixels=5000, n=1,
        breaks = c(-1, 0, 1, 2), col = plot_cols[c(1, 3, 2)])
```


```{r rebecca-senior-time-series}
library(raster)

# Create test matrices with value of:
# 1 for agriculture and 
# 2 for non-agriculture
mat1 <- matrix(rep(1, 9), nrow = 3, ncol = 3)
mat2 <- matrix(c(rep(1, 3), 2, 2, 1), nrow = 3, ncol = 3)
mat3 <- matrix(c(rep(1, 3), rep(c(2, 1, 1), 2)), nrow = 3, ncol = 3)

# Create raster stack, with one raster for each year (randomly)
rastStack <- stack(raster(mat1),
                   raster(mat2), raster(mat2),
                   raster(mat1),
                   raster(mat2), raster(mat3), 
                   raster(mat1))

# Name the years
yrs <- 1:nlayers(rastStack)
names(rastStack) <- paste("yr", yrs, sep = "")

# Have a look
# yr2 -> two cells change to non-agriculture
# yr4 -> the two cells change back to agriculture
# yr5 -> the same two cells change to non-agriculture
# yr6 -> one of the two cells changes back to agriculture
# yr7 -> the other cell also changes back to agriculture

plot(rastStack)
plot(rastStack, breaks = c(-1, 0, 1, 2), col = c("gray", "yellow", "green"))

plot(rastStack, breaks = c(-1, 0, 1, 2), col = rev(terrain.colors(3)))
# 1 = brown, agriculture
# 2 = green, non-agriculture


# Sequential difference between years
# value of 0 = no difference compared to previous year (brown)
# value of 1 = change from agriculture to non-agriculture (green)
# value of -1 = change from non-agriculture to agriculture (gray)
running_diff <- calc(rastStack, fun = diff)
plot(rastStack, breaks = c(-1, 0, 1, 2), col = rev(terrain.colors(3)))
plot(running_diff, breaks = c(-2, -1, 0, 1), col = c("#ECB176FF", # brown
                                                     "#F2F2F2FF", # gray
                                                     "#00A600FF" # green
                                                     ))

# FYI: base::diff() # calculates the differences between each entry in a vector, or in this case, differences between cells across multiple years: i.e. 1987 - 1988, 1989 - 1988, 1990 - 1989, 1991 - 1990, etc.

# Multiply by the year to record the year in which change took place (and whether it was ag -> non-ag [positive], or non-ag -> ag [negative])
running_diff2 <- running_diff * yrs[-1] 
plot(running_diff2)

# Identify years with zero change
minVals <- minValue(running_diff2) # this is the years in which at least one pixel changed from noncrop (2) to crop (1), therefore yielding a negative value. 
minVals

maxVals <- maxValue(running_diff2) # this simply tells you years in which at least one pixel changed from ag to non-ag.
maxVals
# note, this can capture years in which both types of transitions took place (year 6)
nochange <- running_diff2[[which(maxVals == 0 & minVals == 0)]] # which index is 0 in both maxVals and minVals? Subset the stack by that index
plot(nochange)
 
plot(running_diff2) # tells you the year (the absolute value of the cell), and the transition type (negative means non-ag to ag, positive means ag to non-ag) 

# For each cell, we now know the year in which it changed from agriculture to non-agriculture
# and (potentially) back to agriculture (from running_diff2), from which we can calculate
# the number of non-agriculture periods and total time as non-agriculture

# count the number of "transitions", i.e. number of times the cell switched from crop to noncrop
# Number non-agriculture transitions = number years (bands) where cell value is positive
noncrop_count <- sum(running_diff2 > 0)
# Number agriculture reversions = number years (bands) where cell value is negative
crop_count <- sum(running_diff2 < 0)

plot(running_diff2)
plot(noncrop_count)
plot(crop_count)


# Convert original stack to binary -> 1 if non-agriculture, 0 if agriculture
rastStack_bi <- rastStack
rastStack_bi[rastStack_bi == 1] <- 0
rastStack_bi[rastStack_bi == 2] <- 1
# Total time as non-agriculture = sum across years
noncrop_duration <- calc(rastStack_bi, fun = sum)
plot(noncrop_duration)
plot(calc(rastStack, fun = sum))

# Average length of time as non-agriculture = total duration / N non-crop periods
noncrop_duration_avg <- noncrop_duration / noncrop_count
plot(noncrop_duration_avg)

# cell 2 [1,2] changes from agriculture in 2001, back to agriculture in 2003 = 2 years
# cell 2 [1,2] changes from agriculture in 2004, back to agriculture in 2006 = 2 years
# cell 2 [1,2] total time = 4 years; avg time = 4 years / 2 periods = 2 years

# cell 5 [2,2] changes from agriculture in 2001, back to agriculture in 2003 = 2 years
# cell 5 [2,2] changes from agriculture in 2004, back to agriculture in 2005 = 1 year
# cell 5 [2,2] total time = 3 years; avg time = 3 years / 2 periods = 1.5 years

```

```{r test-RS-TS}
animate(btb, pause = 0.5, zlim = c(1, 4), maxpixels=5000, n=1,
        breaks = c(-1, 0, 1, 2), col = plot_cols[c(1, 3, 2)])

plot(bs$smolensk1987, breaks = plot_breaks, col = plot_cols)
plot(bt$smolensk1987, add = T)

plot(btb, breaks = plot_breaks, col = plot_cols) # binary version of bt


# Name the years
yrs <- as.numeric(gsub("smolensk", "", names(btb)))
yrs <- 0:30
plot(btb$smolensk1987)


# Sequential difference between years
# value of 0 = no difference compared to previous year (brown)
# value of 1 = change from agriculture to non-agriculture (green)
# value of -1 = change from non-agriculture to agriculture (gray)
tic()
running_diff <- calc(btb, fun = diff)
toc()

tic()
bs_diff <- calc(bs, fun = diff)
toc()

ncell(btb)
ncell(bs)
ncell(b87_r)

plot(b87_r)
plot(bs$smolensk1987, add = T, col = "red")

plot(bs$smolensk1987)
plot(btb$smolensk1987, add = T, col = "red")



show_col(plot_cols[c(1, 3, 2)])
plot(btb[[1:16]], breaks = c(-1, 0, 1, 2), col = plot_cols[c(1, 3, 2)])
# 1 = brown, crop | 2 = green, noncrop

plot(running_diff[[1:16]], breaks = c(-2, -1, 0, 1), col = plot_cols[c(3, 1, 2)]) # brown (transition noncrop to crop), gray (no trans), green (transition crop to noncrop)
show_col(plot_cols[c(3, 1, 2)])
                                                

# Multiply by the year to record the year in which change took place (and whether it was ag -> non-ag [positive], or non-ag -> ag [negative])
running_diff2 <- running_diff * yrs[-1]
plot(running_diff2)

# identify years with at least one change... (this isn't all that useful, since there is a transition in each year.)
minVals <- minValue(running_diff2) #  years with > 1 transition noncrop (2) to crop (1)
maxVals <- maxValue(running_diff2) # years with > 1 transition crop (1) to noncrop (2)
nochange <- running_diff2[[which(maxVals == 0 & minVals == 0)]] # no changes
 
plot(running_diff2) # tells you the year (the absolute value of the cell), and the transition type (negative means non-ag to ag, positive means ag to non-ag) 

# count the number of "transitions":
noncrop_count <- sum(running_diff2 > 0) # Number transitions to noncrop (# years with positive value)
crop_count <- sum(running_diff2 < 0) # Number transitions to crop (# years with negative value)

plot(noncrop_count, main = "# transitions crop -> noncrop")
plot(crop_count, main = "# transitions noncrop -> crop")

object_size(running_diff2)



# Convert original stack to binary -> 1 if non-agriculture, 0 if agriculture
btb_bi <- btb
btb_bi[btb_bi == 1] <- 0
btb_bi[btb_bi == 2] <- 1
# Total time as non-agriculture = sum across years
noncrop_duration <- calc(btb_bi, fun = sum)
plot(noncrop_duration)

# Average length of time as non-agriculture = total duration / N non-crop periods
noncrop_duration_avg <- noncrop_duration / noncrop_count
plot(noncrop_duration_avg)

```


```{r prep_data.table}
bdt <- as.data.table.raster(bt)
names(bdt) <- gsub("smolensk", "y", names(bdt))
bdt[, c("x", "y") := NULL]
bdt

# update options for printing (it defaults to 100)
# options(datatable.print.nrows = 20)
# print(bdt, nrows=20)

# -------------------
# replace values (not sure if there is a faster way to do this, but it works, for now)
tic()
bdt[bdt == 1] <- NULL # nonveg
bdt[bdt == 3] <- 1 # crop
bdt[bdt == 4] <- 2 # noncrop
toc()

dt_b87 %>% object_size()

DT <- bdt[1:15, 1:14]
tic()
# can also do this, and loop through all the columns
# note, changing the nonveg to NA may prove problematic later
for (x in names(DT)) {set(DT, which(DT[[x]] == 1), x, NA)}        # nonveg (urban, water, etc.)
for (x in names(DT)) {set(DT, which(DT[[x]] == 3), x, 1)}         # crop
for (x in names(DT)) {set(DT, which(DT[[x]] %in% c(2, 4)), x, 2)} # noncrop
toc() # a bit faster. It's about 24 seconds on the big file

DT

bin <- DT - 1
# 1 for noncrop
# 0 for crop

# row sums... there isn't anything more efficient than rowSums()
bin[, sum := rowSums(.SD, na.rm = TRUE)][] 
# note that you can also do this over a subset of columns, by selecting columns with .SDcols, like so:
bin[, sum2 := rowSums(.SD, na.rm = TRUE), .SDcols = grep("8", names(bin))][] 
bin[1, y1987:y2000] %>% length()


# --------------
# diff with data.table...
# --------------
# first, copy the data.table, then remove the first column, add a NA column at the end.
# then simply subtract the two DT
DT_lead <- copy(DT)
DT_lead[, y1987 := NULL][, end := NA]

DT_diff <- DT_lead - DT # this works just the same.
DT_diff[, end := NULL]

# using apply works too, but it's slow with big data.tables
# this works on either data.frames or data.tables, but it's really slow with big data.tables, since it has to transpose all the rows. 
tic(); t(apply(as.data.frame(DT), 1, diff)); toc()
tic(); t(apply(DT, 1, diff)); toc()

diff2 <- copy(DT)
diff2[, sum3 := sum(.SD, na.rm = TRUE), by = seq_len(nrow(DT_diff))]

dt_b87[, ':='(v1 = 1, v2 = 2, v3 = 3)]
big_df <- as.data.frame(dt_b87)
head(big_df)
tic()
diffbig <- t(apply(dt_b87, 1, diff)) %>% data.table()
toc() # this didn't even finish after nearly 2 hours.

# testing the simple method with a big file. I'll probably run out of memory on my computer, and will have to do this on a cluster.
tic()
DT_big <- copy(dt_b87)
toc() # 4.5 sec

DT_big[, x := NULL][, end := NA]

tic()
DT_bigdiff <- DT_big - dt_b87 # this works just the same.
DT_bigdiff[, end := NULL]
toc() # 12.71 seconds



# ---------------------------------------------------------------------------
# performing functions on individual rows
# ---------------------------------------------------------------------------
# one way is by using by = 1:nrow

DT
DT_diff # 1 means change from crop (1) to non crop (2), i.e. abandonment
# -1 means change from noncrop (2) back to crop (1), i.e. recultivation
backup_diff <- copy(DT_diff)
DT_diff <- copy(backup_diff)

DT
dt_b87 # 94 million rows.

rowSums(DT_diff)





# -------------------
# this works for rowSums
DT_diff[, sum := rowSums(.SD, na.rm = TRUE)]
ncol(DT_diff)
DT_diff[, sum2 := rowSums(.SD, na.rm = TRUE), .SDcols = 1:13] # select columns
tic(); dt_b87[, sum2 := rowSums(.SD, na.rm = TRUE), .SDcols = 4:6]; toc() # 5.5 seconds
dt_b87[, sum2 := NULL]

DT_diff

# this works to apply functions to each individual row: the same as by = 1:nrow(DT)
DT_diff[, sum3 := sum(.SD, na.rm = TRUE), by = seq_len(nrow(DT_diff)), .SDcols = 1:13]
DT_diff[, sum4 := sum(.SD, na.rm = TRUE), by = 1:nrow(DT_diff), .SDcols = 1:13]
# the .SD in the j part of the data.table should refer to the subset of DT calculated by by
# which means..... I shouldn't have to subset it further. .SD > 0 should work as a logical statement
DT_diff[, sum4:=NULL][, sum3:=NULL]

# doesn't work
# DT_diff[, sum4 := sum(.SD, na.rm = TRUE), .SDcols = .SD > 0, by = seq_len(nrow(DT_diff))]
# DT_diff[, sum4 := sum(.SD[.SD > 0], na.rm = TRUE), by = seq_len(nrow(DT_diff))]
DT_test <- DT_diff[, .SD > 0][] %>% data.table()
DT_test[, positive := rowSums(.SD, na.rm = TRUE)][]
```


```{r age-per-pixel}
# Filtering steps:
# 1. Must have crop at some point in the time series.
# 2. Must have crop specifically before noncrop transition. 

age <- copy(bin)

# or make your own
set.seed(34L)
age <- matrix(round(runif(15*15)), nrow = 15, ncol = 15) %>%
  as.data.frame()
setDT(age)
# age <- as.data.table(age) # also works, but is less efficient because it creates a copy in memory. Not a big deal either way though.

age


# update the names
names(age) <- paste0("y", 1:ncol(age))

# ---------------------------------------------------------------------------
# calculate age of each pixel, for just one column
# ---------------------------------------------------------------------------
age[y2 > 0, y2 := y1 + 1][]

# this code does the following:
# take age, subset rows where y2 > 0, and 
# then set those equal to the value in column y1 for that row + 1.
# Note: the [] at the end prints the result.

# in order to loop over the columns, the code needs some massaging to get it to accept
# character vectors, which can be referenced with indices to be looped over
age[get(names(age)[2]) > 0, c(names(age)[2]) := get(names(age)[1]) + 1][]


# --------------------------------------------
# full implementation with a for loop - the final code
# --------------------------------------------
for (i in 2:ncol(age)) { # start with the second column
  age[get(names(age)[i]) > 0, c(names(age)[i]) := get(names(age)[i-1]) + 1]
  }
print(age)


# --------------------------------------------
# try it with a bigger data.table
age <- copy(bin)
# make age big:
for (i in 1:22) {
  age <- rbind(age, age)
}
age <- cbind(age, age[, 1:5])
object_size(age); nrow(age)
names(age) <- paste0("y", 1:ncol(age))

tic()
for (i in 2:ncol(age)) {
  age[get(names(age)[i]) > 0, c(names(age)[i]) := get(names(age)[i-1]) + 1 ]
}
toc() # 2.6 seconds on 491,520 rows
# 81.829 seconds for 62,914,560 rows. Wow! This should work fine, as long as I can figure out a good way to load in all that data. 




# ---------------------------------------------------------------------------
# ---------------------------------------------------------------------------
# ---------------------------------------------------------------------------
# old, unused, test code
# ---------------------------------------------------------------------------
# ---------------------------------------------------------------------------
# ---------------------------------------------------------------------------

# trying it with set
# -------------------------------
tic()
for (x in 2:ncol(age)) {
  set(age, 
      which(age[[names(age)[x]]] > 0), 
      j = names(age)[x], 
      value = age[get(names(age)[x]) > 0, get(names(age)[x-1])] + 1)
}
toc() # 94.22 seconds for 64 million rows
# this worked too, but it's a bit slower. I'll use the other since it's simpler, and keep this in the back pocket until then. 


# original code
# -------------------------------
# You'll note that this code works on each column. My previous code worked on individual values in each row individually, then looping over the columns, then over all the rows. This ultimately ended up being much, much slower. I realized that data.tables could be subset up front based on values in a column, and then those values could be easily manipulated. It turns out it's much easier to iterate over columns than over rows, especially when we have something like 90 million rows!

# the old code looked like this:
for (i in 1:nrow(dt)) {
  for (j in 2:ncol(dt)) {
    if (dt[i][[names(dt)[j]]] > 0) {
      dt[i][[names(dt)[j]]] <- dt[i][[names(dt)[j - 1]]] + 1
    }
  }
}
# 0.131 sec for just 15 rows
# 254.958 sec for 15,000 rows
# so, estimating what it would take to do 94 million rows.
(94000000/15000 * 254) / 60 / 60 # jeeeeez 442 hours. That's untenable.


# potentially useful things:
# ------------------------------
vec <- unlist(dt[1], use.names = FALSE) # extract a row as a vector


# data.table syntax
dt[, sum := sum(.SD, na.rm = TRUE), by = seq_len(nrow(dt))]
dt[, rowsum := rowSums(.SD, na.rm = TRUE), .SDcols = 1:14]


```




```{r plot-trajectory-per-pixel}
ncell(bt)
# subset the data.table, for plotting
sub <- dt_bs[1:10, -c(1,2)]
names(sub) <- gsub("y", "", names(sub))
sub[, pixel := c(1:10)]
sub


sub_melt <- melt(sub, id.vars = "pixel", 
                 variable.name = "year", 
                 value.name = "land_use", na.rm = TRUE)

sub_melt$year <- gsub("y", "", sub_melt$year)

str(sub_melt)

# set colors for plotting
show_col(terrain.colors(9))

lc_cols <- scale_color_manual(name = "Land Cover",
                     labels = c("1" = "1. Non-veg",
                                "2" = "2. Woody veg",
                                "3" = "3. Crop",
                                "4" = "4. Grassland"),
                     values = c("1" = "gray80",
                                "2" = terrain.colors(9)[1], # dark green
                                "3" = terrain.colors(9)[5], # gold
                                "4" = terrain.colors(9)[3] # light green
                                )
                     ) 

# this plot shows the land-use trajectories of 10 individual pixels.
gg_10_px_traj <- ggplot(data = sub_melt, 
                        mapping = aes(x = year, y = land_use, group = pixel)) +
  theme_classic() + 
  theme(axis.text.x = element_text(angle = 320, vjust = 1, hjust = 0)) +
  geom_line(mapping = aes(color = factor(land_use)), size = 2) +
  facet_grid(rows = vars(pixel), scales = "free_x", switch = "x") + 
  ylim(1, 4) + lc_cols

gg_10_px_traj
#       1. Non-vegetated area (e.g. water, urban, barren land)
#       2. Woody vegetation
#       3. Cropland 
#       4. Herbaceous land (e.g. grassland)


```
Here's the game plan:
With RS' code, I have the following:
- the year of changes, and 




```{r dt-testing}
library(data.table)
set.seed(1L)
test
## Create a data table
DT <- data.table(V1 = rep(c(1L, 2L), 5)[-10],
                V2 = 1:9,
                V3 = c(0.5, 1.0, 1.5),
                V4 = rep(LETTERS[1:3], 3))

class(DT)
DT

DT[V1 == 1]

DT[, sum(V1)]
```







